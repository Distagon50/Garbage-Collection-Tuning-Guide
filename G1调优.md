## General Recommandations for G1
一般的建议是使用G1的默认设置，最终给它一个不同的暂停时间目标，并在需要时使用-Xmx设置最大的堆大小。
 
G1的默认值与其他收集器有所不同。G1的默认配置的目标既不是吞吐量最大化，也不是延迟最低，而是在高吞吐量时提供相对较小的、均匀的暂停。但是，G1增量的回收堆空间的机制和暂停时间控制会在应用程序线程和空间回收效率中带来一些开销。
 
如果你想要高吞吐量，那么可以使用-XX:MaxGCPauseMillis来降低暂停时间目标或提供更大的堆空间。如果(低)延迟是最主要的考量，那么修改暂停时间目标。避免通过使用-Xmn、-XX:NewRatio等选项将年轻代大小限制为特定值。因为年轻代大小是G1满足暂停时间的主要手段。将年轻一代的大小设置为单个值会覆盖，甚至实际上禁用了暂停时间控制。
 
## 从其他收集器迁移到G1
一般来说，当从其他收集器(特别是并发标记清理收集器CMS)迁移到G1时，首先删除所有影响垃圾收集的选项，然后使用-Xmx和可选的-Xms设置暂停时间目标和总体堆大小。
 
对于许多其他收集器以某种特定方式响应的有用选项，它们(对G1)要么根本不起作用，或者甚至会降低吞吐量，以及实现暂停时间目标的可能性。一个例子是设定年轻代的大小，这会让G1完全无法调整年轻代的尺寸以满足暂停时间的目标。
 
## 提升G1收集器的性能
G1的设计目的是在不需要额外指定其他选项提供良好的总体性能。然而，有些情况下，默认的启发式方法或是默认配置提供了次优结果。本节给出一些关于诊断和改进这些情况的指导意见。本指南只描述了G1在给定的应用程序中提供垃圾收集器性能改进的可能性。但，具体情况具体分析，应用程序级的优化可能比试图优化VM来的更好更有效，例如，通过减少出现长时间存活的对象来避免某些有问题的场景来。
 
G1提供全面的日志记录用以诊断。使用-Xlog:gc*=调试选项，然后根据需要对输出进行优化会是一个好的开始。日志提供了垃圾收集活动和暂停期间的详细概述。这些信息包括垃圾收集的类型和在特定的暂停阶段所花费的时间的细分。
 
下面的小节将讨论一些常见的性能问题。
 
# 对全堆垃圾收集点观察
全堆垃圾收集(Full GC)通常非常耗时。Full GC是由老年代中过高堆占用所导致的，可以通过在日志中查找Pause Full(Allocation Fail)等词而检测到。Full GC通常出现在由to space耗尽的标记所指示的疏散失败的垃圾收集前。
 
之所以会出现Full GC，是因为应用程序分配了太多无法快速回收的对象。经常导致并发标记不能及时完成，以启动空间回收阶段。大量巨型对象的分配会使进入Full GC的可能性变得更加复杂。鉴于这些对象在G1中的分配方式，它们占用的内存可能比预期的多得多。
 
目标应该是确保并发标记能够按时完成。这可以通过降低老年代的分配率来实现，也可以让并发标记有更多的时间来完成。
 
G1提供了几个选项能够更好地处理这种情况:
 
如果Java堆上有大量的巨型对象，那么gc+heap=info日志记录会将这个数字显示在巨型对象所在区域旁边。在每次垃圾收集之后，最好的选择是尝试减少对象的数量。可以通过使用
-XX:G1HeapRegionSize选项增加单位区域的大小来实现这一点。当前选择的堆区域大小会被打印在日志的开头。
 
增加Java堆的大小。这通常会增加完成标记所需的时间。
 
通过显式地设置-XX:ConcGCThreads来增加并发标记线程的数量。
 
迫使G1提前开始标记。G1根据早期应用程序行为自动确定初始堆占用百分比(IHOP)阈值。如果应用程序行为发生变化，那么这些预测就可能是错误的。有两种选择:通过修改-XX:G1ReservePercent增加用于自适应IHOP计算的缓冲区来降低何时开始空间回收的目标区域占用率;或者，通过使用-XX:-G1UseAdaptiveIHOP和-XX: InitiatingHeapOccupancyPercent来手动设定IHOP的值来禁用它的自适应计算。
 
除分配失败之外，其他导致Full GC的原因通常表明，应用程序本身或某些外部工具引起了Full GC。如果原因是System.gc()，并且没有办法修改应用程序源代码，那么可以通过使用-XX:+ indeitgcinvokesconcurrent来减轻Full GC的影响，或者通过设置-XX:+DisableExplicitGC来让VM完全忽略它们。外部工具仍然可以强制Full GC，它们只能通过不请求(Full GC)来避免。
 
# 巨型对象导致的碎片化
由于需要为这些巨型对象找到一组连续的区域，因此在所有Java堆内存耗尽之前就可能会出现Full GC。在这种情况下，可能的选项是通过使用选项-XX:G1HeapRegionSize来增加单位堆区域的大小以减少巨型对象的数量，或者增加整个堆的大小。在极端情况下，即使可用内存足够，G1也可能因为没有足够的连续空间来分配对象。此时如果Full GC不能回收足够的连续空间，就会导致VM Exit。结果就是，除了减少前面提到的减少巨型对象分配数量或增加堆之外，没有其他选择。
 
# 对延迟的调优
本节讨论在常见的延迟问题(即暂停时间过高)中改进G1行为的一些建议。
不寻常的系统或实时使用
对于每一个垃圾收集暂停，gc+cpu=info日志输出会有一行，其中包括操作系统的信息，和在暂停期间时间在何处花费的信息。该输出的看起来像是这样User=0.19s Sys=0.00s, Real=0.01s。
用户时间是在VM代码中花费的时间，系统时间是在操作系统中花费的时间，而实时时间是在暂停期间经过的绝对时间。如果系统时间比较长，那么最常见的原因就是环境。
高系统时间的常见已知问题有:
VM内存分配或从操作系统返回内存可能导致不必要的延迟。通过使用选项-Xms和-Xmx将最小和最大堆大小设置为相同的值，并使用-XX:+AlwaysPreTouch预触所有内存，以将该工作转移到VM启动阶段从而避免延迟。
特别是在Linux中，通过THP特性将内存小分页合并成大分页往往会导致随机进程的停止，而不仅仅是在暂停的时候。因为VM分配和维护了大量内存，所以很有可能VM将成为长期停滞的进程。请参阅操作系统的文档，了解如何禁用THP特性。
由于某些后台任务会间歇性地占满日志写入硬盘的所有I/O带宽，因此日志输出可能会暂停。可以考虑为日志使用单独的磁盘，或者其他类型的存储，例如基于内存的文件系统以避免这种情况。
另一种需要注意的情况是实时时间要比其他的总和大得多，这可能表明VM在可能负载过重的机器上没有获得足够的CPU时间。
引用对象处理花费的时间太长
有关处理引用对象所需时间的信息显示在Ref Proc和Ref Enq阶段中。在Ref Proc阶段，G1根据引用对象的类型来更新引用对象的引用。在Ref Enq中，如果发现指向对象的引用已死，G1将引用对象放入各自的引用队列中。如果这些阶段花费的时间太长，那么可以考虑使用选项-XX:+ParallelRefProcEnabled来实现这些阶段的并行化。

Young-only 阶段需要很长时间
一般来说，Young-only和任何年轻代的垃圾回收所需的时间都与年轻代的大小成正比，或者更确切地说，与集合中需要复制的的活动对象的数量成正比。如果Evacuate Collection Set阶段花费的时间太长，特别是对象复制子阶段，则减少-XX:G1NewSizePercent的值。这会减少了年轻代的最小尺寸，允许更短的停顿。
 
如果应用程序性能，特别是垃圾收集后存活的对象数量突然发生变化，那么年轻代的大小可能会出现另一个问题。这可能会导致垃圾收集暂停时间的峰值。使用-XX:G1MaxNewSizePercent来减少最大的年轻代大小可能是有用的。这会限制年轻代的最大大小，因此需要在暂停期间处理的对象的数量也会相应减少。
 
混合收集花费的时间太长
混合收集被用来回收老年代的空间。混合收集包含年轻代和老年代区域。通过启用gc+ergo+cset=trace日志输出，可以获得关于年轻或年老代区域的疏散对暂停时间的影响程度的信息。分别观察预测的年轻代时间和预测的老年代时间。
 
如果预计的年轻代时间太长，参见上一个小节。否则，为了减少老年代区域对停顿时间的影响，G1提供了如下三种选择:
 
通过增加-XX:G1MixedGCCountTarget，将老年代区域回收扩展至更多的垃圾收集中。
 
通过使用-XX:G1MixedGCLiveThresholdPercent不将需要大量时间收集的区域放入候选区域集合中来避免收集它们。在许多情况下，高度被占用的地区需要花费大量的时间来收集。
 
尽早停止老年代的空间回收，让G1不会收集太多的高占用区域。在这种情况下，增加-XX: G1HeapWastePercent的值。
 
注意，最后两个选项减少了集合候选区域的数量，在这些区域中可以为当前的空间回收阶段回收空间。这可能意味着G1可能无法在老年代中回收足够的空间来持续运行。但是，之后的空间回收阶段可能会对它们进行垃圾收集。
 
高更新RS和扫描RS时间
为了使G1能够疏散单个老年代区域，G1会追踪跨区域的引用，亦即从一个区域到另一个区域的引用。指向给定区域的跨区域引用集称为该区域的记忆集。当移动给定区域的内容时，相应的记忆集也必须被更新。区域记忆集的维护通常是并发的。出于性能目的，当应用程序在两个对象之间生成新的跨区域引用时，G1不会立即更新区域的记忆集。为了提高效率，会延迟并批处理区域的记忆集更新请求。
 
G1需要完整的记忆集以完成垃圾收集，因此垃圾收集的Update RS阶段会处理任何未完成的记忆集更新请求。Scan RS阶段在记忆集中搜索对象引用，移动区域内容，然后将这些对象引用更新到新的位置。根据应用程序的不同，这两个阶段可能需要大量的时间。
 
使用选项-XX:G1HeapRegionSize调整堆的单个区域大小会影响跨区域引用的数量以及记忆集的大小。处理记忆集是垃圾收集工作非常重要的一部分,这直接影响了可实现的最大暂停时间。较大的单位区域往往具有较少的跨区域引用，因此处理它们所需的相对工作量也相应减少。但与此同时，较大的单位区域可能意味着每个区域有更多的活动对象需要被疏散，从而会增加了他阶段的耗时。
G1试图调度记忆集更新工作以使其并发处理，以便Update RS阶段大约占用允许的最大暂停时间的-XX:G1RSetUpdatingPauseTimePercent。如果减少这个值，G1通常使更多记忆集更新工作并发。
 
伴随着分配大型对象过程的虚假的高Update RS次数可能是由于优化策略试图通过批处理来减少并发的记忆集更新工作而导致的。如果应用程序恰好在垃圾收集之前创建此类批处理，那么垃圾收集就必须在垃圾收集暂停的Update RS中处理所有这些工作。使用-XX:-ReduceInitialCardMarks来禁用此行为就有可能避免这种情况。
 
Scan RS时间由G1执行的压缩量决定，这个压缩量是为了使记忆集的存储大小保持在较低的水平。存储在内存中的记忆集越紧凑，在垃圾收集期间检索存储值的时间就越长。当G1基于该区域当前记忆集的大小开始更新它的时候，G1会自动执行这种压缩，称为记忆集粗化。
选项-XX:G1SummarizeRSetStatsPeriod 结合gc+remset=trace级别的日志记录显示这种粗化是否发生。如果是这样，那么在之前Before GC Summary章节中显示的Did <X> coarsenings中的X会呈现一个比较高的值。可以显著增加-XX:G1RSetRegionEntries选项的值来减少这些粗化的数量。我们需要避免在生产环境中使用这种详细的记忆集日志记录，因为收集这些数据可能需要大量的时间。
 
针对吞吐量的调优
G1的默认策略是试图在吞吐量和延迟之间保持平衡。但是，有些情况下需要更高的吞吐量。除了将前几节中所描述的总体停顿时间减少，还可以减少停顿的频率。主要思想是通过使用-XX:MaxGCPauseMillis来增加最大暂停时间。代际大小试探法将自动调整年轻代的大小，这直接决定了停顿的频率。如果这没有达到预期的目的，特别是在空间再利用阶段，使用-XX:G1NewSizePercent增加最小的年轻代大小将迫使G1这样做（减少GC的停顿频率）。
 
在某些情况下，-XX:G1MaxNewSizePercent定义的最大年轻代大小，会通过限制年轻代的大小从而限制吞吐量。这可以通过查看gc+heap=info日志记录的区域汇总输出诊断出来。在这种情况下，Eden区域和幸存者区域的总和比例接近-XX:G1MaxNewSizePercent所定义的总区域占比。我可以考虑增加
-XX:G1MaxNewSizePercent。
 
增加吞吐量的另一个选项是尽量减少并发工作的数量，并发的记忆集更新通常需要大量的CPU资源。增加-XX:G1RSetUpdatingPauseTimePercent将工作从并发操作移动到垃圾收集暂停时来完成。在最坏的情况下，可以通过设置 -XX:-G1UseAdaptiveConcRefinement -XX:G1ConcRefinementGreenZone=2G -XX:G1ConcRefinementThreads=0来禁用并发记忆集更新。这基本上会禁用此机制，并将所有记忆集更新工作移到下一次垃圾收集暂停中。
 
通过使用 -XX:+UseLargePages来启用大页面也可以提高吞吐量。请参阅操作系统文档中关于如何设置大页面的内容。
 
你可以通过禁用堆大小调整工作来将其工作量最小化;将选项-Xms和-Xmx设置为相同的值。此外，你还可以使用-XX:+AlwaysPreTouch将操作系统从物理内存中分配空间的操作都在VM加载时完成。为了使暂停时间更加一致，这两种方法都是特别可取的。
 
Tuning for Heap Size
与其他收集器一样，G1的目标是对堆进行大小调整，以便在垃圾收集中花费的时间低于-XX:GCTimeRatio选项所确定的比率。调整此选项，使G1满足您的需求。
 
可调的默认值
本节描述在本主题中介绍的默认值和一些关于命令行选项的附加信息。
Table 10-1 G1 GC可调整默认值

选项及其默认值
miaos
-XX:+G1UseAdaptiveConcRefinement
-XX:G1ConcRefinementGreenZone=<ergo>
-XX:G1ConcRefinementYellowZone=<ergo>
-XX:G1ConcRefinementRedZone=<ergo>
-XX:G1ConcRefinementThreads=<ergo>
并发记忆集更新（细分）使用这些选项来控制并发优化线程的工作分布。G1为这些选项选择符合人机工程学的值，以便 -XX:G1RSetUpdatingPauseTimePercent所定义的时间都花在了在垃圾收集暂停中去处理（记忆集更新）剩下的工作，你可以根据需要动态的去调整他们。但要小心，因为这可能会导致非常长的停顿。

-XX:+ReduceInitialCardMarks
将用于初始对象分配的并发记忆集更新(细化)工作批处理化。
-XX:-ParallelRefProcEnabled
这决定了对 java.lang.Ref.*的实例化是否会交由多个线程并行。
-XX:G1RSetUpdatingPauseTimePercent=10 
这个决定了G1应当话费总GC时间的多少在更新RS阶段用以更新任何尚未更新的记忆集。G1通过这个设定来控制并发记忆集更新的数量。
-XX:G1SummarizeRSetStatsPeriod=0 
这是G1在某些GC中生成记忆集摘要报告的一些周期。将值设置为零以禁用此功能。生成记忆集摘要报告是一项昂贵的操作，因此只有在必要，并且具有相当高的价值的时候才应该使用它。使用gc+remset=trace来打印所有关于次操作的信息。
-XX:GCTimeRatio=12 
这是与应用程序相对的应该用于垃圾收集的目标时间比的除数。在G1决定增加堆大小之前，确定垃圾收集可以花费的目标时间比例的实际公式是1 / (1 + GCTimeRatio)。这个默认值将导致有大约8%的时间用于垃圾收集。
