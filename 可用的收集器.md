Java HotSpot VM包括三种不同类型的收集器，每种收集器具有不同的性能特征。

Serial Collector
=

串行收集器使用单线程执行所有垃圾收集工作，所以它相对高效，因为不会有线程间的通信开销。

它最适合于单处理器机器。尽管它也可以在多处理器上的小数据集(大约100 MB)的应用程序上使用，但它并不能发挥多处理器的优势。
在某些硬件和操作系统配置上默认会启用串行收集器，或者也可以通过选项-XX:+UseSerialGC启用。

Parallel Collector
=

并行收集器也称为吞吐量收集器，它是类似于串行收集器的分代收集器。串行和并行收集器之间的主要区别是并行收集器是多线程工作以加速垃圾收集。

并行收集器适用于多处理器或多线程硬件上运行的中到大型数据集的应用程序。可以用-XX:+UseParallelGC来启用。

并行压缩是并行收集器可以并行执行Major GC的特性。如果没有并行压缩，Major GC将使用单线程执行，这将极大地限制可伸缩性。
如果已经选择了选项-XX:+UseParallelGC，那么并行压缩也会默认启用。可以使用-XX:-UseParallelGC选项来禁用它。

The Mostly Concurrent Collectors
=

并发扫描-标记(CMS)收集器和Garbage-First(G1)是两个主要并发收集器。对应用程序来说，Mostly Concurrent Collector并发的执行一些昂贵(开销巨大)的工作。

	• G1垃圾收集器:这个server-style的收集器是为具有大内存的多处理器机器(设计)的。它在实现高吞吐量的同时，大概率可以满足垃圾收集暂对停时间的要求。
	G1在某些硬件和操作系统配置上是默认启用的，或者可以用-XX:+UseG1GC显式启用。

	• CMS收集器:该收集器更适用于偏向较短的垃圾收集暂停，并且能够负担与垃圾收集共享处理器资源的开销的应用程序。
	使用选项-XX:+UseConcMarkSweepGC来启用CMS收集器。

在JDK 9中，CMS收集器已被弃用。

Selecting a Collector
=

除非您的应用程序具有相当严格的暂停时间要求，否则先运行应用程序并允许VM自动选择收集器。
如果需要，可以调整堆大小以提高性能。如果性能仍然没有达标，可以基于如下原则来选择垃圾收集器:

	• 如果应用程序的数据集很小(最大约为100 MB)，可以选择用-XX:+UseSerialGC启用串行收集器。
	• 如果应用程序在单处理器上运行，并且没有暂停时间的要求，可以用-XX:+UseSerialGC启用串行收集器。
	• 如果
		(a) 应用程序的峰值性能是第一优先级。
		(b) 没有暂停时间的要求或一秒及以上时间的暂停可以接受，那么让VM自动选择收集器，或者用-XX:+UseParallelGC来选择并行收集器。
	• 如果响应时间比总体吞吐量更重要，并且垃圾收集暂停时间必须保持在大约1秒的时间内，那么用-XX:+UseG1GC或-XX:+UseConcMarkSweepGC选择一个并发收集器。

这些指导原则仅为选择收集器提供了一个起点，因为性能取决于堆的大小、应用程序维护的实时数据量以及可用处理器的数量和速度。暂停时间对这些因素都特别敏感，
所以前面提到的一秒钟的阈值只是近似的。并行收集器在许多堆大小和硬件组合上的暂停时间超过1秒。相反，在某些情况下，并发收集器可能无法保持暂停时间短于1秒。

如果推荐的收集器没有达到预期的性能，那么首先尝试调整堆和各世代的大小以满足期望的目标。如果性能仍然捉襟见肘，才开始尝试不同的收集器:
使用并发收集器来减少暂停时间，或使用并行收集器来提高多处理器的总体吞吐量。
